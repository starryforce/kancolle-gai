# Attention!
* 目前仅需要学习1-9章
* 第五章可以*跳过*或推迟，可仅先看*5.1.1*
* 第六章可以*跳过*或在第二章之后、SQL之前看
* 第七章可以在三、四、五章之前

> 综上，顺序为
> 1. 第一章
> 2. 第二章
> 3. 第七章
> 4. 第三章
> 5. 第四章
> 6. 第八章
> 7. 第九章

# 第一章 引言
信息存储结构的定义，信息操作机制的提供

## 1.2 数据库系统的目标
文件处理系统被操作系统直接支持，但不具备通用性
* 数据的冗余和不一致
* 数据访问困难
* 数据孤立
* 完整性问题
* 原子性问题
* 并发访问异常
* 安全性问题

## 1.3 数据视图
提供数据的抽象视图来隐藏底层的实现细节，使得使用者关注于业务。

### 1.3.1 数据抽象
* 物理层
* 逻辑层 具有物理数据独立性
* 视图层 提供关于具体业务的数据，只是数据库的一部分

### 1.3.2 实例和模式
实例：特定时刻存储在数据库中的信息集合

模式：数据库的总体设计
* 物理层 -- 物理模式     <=不关注
* 逻辑层 -- **逻辑模式** <=重点
* 视图层 -- 子模式       <=在后台koa中处理

### 1.3.3 数据模型
数据模型：描述数据、数据联系、数据语义和一致性约束的概念工具的集合。
* 关系模型：用表的集合来表示数据和数据间的联系
* 实体-联系模型：现实世界由一组被称为实体的基本对象和这些对象间的联系构成。
另外还有基于对象的数据模型、半结构化数据模型、网状数据模型、层次数据模型等。

## 1.4 数据库语言

### 1.4.1  数据操纵语言 DML
* 过程化DML 指定需要 what & how
* 声明式DML 只需指定需要 what

### 1.4.2 数据定义语言 DDL
一致性约束会在数据变更前进行检查，拒绝违反一致性约束的操作。
* 域约束
* 参照完整性
* 断言
* 授权
DDL的输出存放在数据字典中，数据字典包含了元数据。

## 1.5 关系数据库

## 1.6 数据库设计

### 1.6.1 设计过程
1. 了解用户的需求，制定用户需求的规格文档
2. 概念设计，描述数据及它们之间的联系
    * 数据库需要那些属性
    * 如何将这些属性组织到多个表中：1.使用实体-联系模型 2.引入一套算法
3. 功能需求说明
4. 逻辑设计阶段：将高层的概念模式映射到要使用的数据库系统的实现数据模型上
5. 物理设计阶段

# 第二章 关系模型介绍

现实世界 => 实体-联系模型 => 关系模型 => 数据库表

## 2.1 关系数据库的结构
关系数据库由表的集合构成，每个表有唯一的名字。

在关系模型术语中，关系用来指代*表*，元组用来指代*行*，属性指代表中的*列*。

关系实例表示一个关系的特定实例

对于关系的每个属性，都存在一个允许取值的集合，称为该属性的*域*。

域是*原子的*，不可再分（根据实际使用方式确定）的单元。

## 2.2 数据库模式
* 数据库模式：数据库的逻辑设计
* 数据库实例：给定时刻数据库中数据的一个快照

## 2.3 码
一个关系中没有两个元组在所有属性上的取值都相等
* *超码*是一个或多个属性的集合，这些属性可以使我们在一个关系中唯一地标识一个元组
* 一个超码的任意真子集都不能成为超码，这样的最小超码称为*候选码*。
* *主码*是被选定主要用来在一个关系中区分不同元组的候选码。

码的指定代表了被建模事物在现实世界的约束。

一个关系模式（如 r1）可能在它的属性中包括另一个关系模式（如 r2）的主码。这个属性在 r1 上称作参照 r2 的*外码*。关系 r1 也被称作外码依赖的参照关系，r2 叫做外码的被参照关系

参照完整性约束：参照关系中任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值。

## 2.4 模式图

## 2.5 关系查询语言

## 2.6 关系运算
关系运算的结果总是单个的关系。
| 运算     | 作用           |
| :------- | :------------- |
| 选择     | 筛选元组       |
| 投影     | 筛选属性       |
| 自然连接 | 合并为单个元组 |
| 笛卡尔积 | 元组数量倍增   |
| 并交差   | 扩展元组数量   |

# 第七章 附加节
实体集用属性表示则是代表该对象只有一个这种属性
如果有多个则需要另外拆分出一个联系集，以其主键作为联系的主键，关联多个值。


# 第七章 数据库设计和 E-R 模型
最终，数据库设计将会表示为一个关系数据库设计和一个与之关联的约束集合。
本章讲述一个 E-R 设计如何转换成一个关系模式的集合以及如何在该设计中找到某些约束。
第8章检验关系模式的质量

## 7.1 设计过程概览
主要任务是数据库模式的设计

### 7.1.1 设计阶段
因为需要与应用使用者沟通明确功能需求，所以需要高层方式来作为桥梁表达诉求。
1. 用户需求规格说明（在此仅文字表述）
2. 概念设计（即应用实体-联系模型，创建图示）定义实体、实体属性、实体间联系和联系约束
3. 功能需求规格说明，检查数据模式是否满足需求
4. 逻辑设计（**从实体-联系模型** 映射到 **关系数据模型**）
5. 物理设计

### 7.1.2 设计选择
两个常见的主要缺陷:
* 冗余:可能导致信息不一致
* 不完整：缺失实现某些更具体细节需求的能力
科学和好的品味的选择，没有绝对意义上的对错

## 7.2 实体-联系模型
实体集、联系集和属性
### 7.2.1 实体集
* **实体集**是相同类型即具有相同性质（或属性）的一个实体集合
* **实体集的外延**表示实体集的实体的实际集合

### 7.2.2 联系集
* 联系：多个实体间的相互关联
* 参与：实体集之间的关联
* 角色：实体在联系中扮演的功能


* 联系可以具有*描述性*属性
* 给定的联系集中一个联系实例必须是由其参与实体唯一标识的，即描述属性不构成主键组成部分。
* 参与联系集的实体集的数目称为联系集的度

### 7.2.3 属性
每个属性都有一个可以取值的集合，称为该属性的**域**，或者**值集**。

* 简单、复合属性。复合属性可以再次划分
* 单值、多值属性
* 派生属性。从别的属性或实体派生出来,本身不需要保存。
* 空值

## 7.3 约束
### 7.3.1 映射基数
映射基数，或基数比率，表示一个实体通过一个联系集能关联的实体的个数

> 约束存在于**实体集和实体集**之间
* 一对一 
* 一对多
* 多对一
* 多对多

### 7.3.2 参与约束
> 约束存在于**实体集和联系集**之间的
* 全部
* 部分

### 7.3.3 码
> 约束存在于**实体本身**
实体可以通过属性唯一的标识自己，区别于其他实体

联系也通过码来保证唯一性，所有参与联系的实体集的主码，他们的并集就是联系集的**超码**。

重名属性必须重命名。可以采用如下策略：
* 实体集的名字加上属性名构成唯一的名称
* 同实体多次参与，用角色名代替实体集名。

联系集的主码结构依赖于联系集的映射基数
* 一对一   任意其中一个
* 一对多   多的那个
* 多对一   多的那个
* 多对多   亮着的并集

## 7.4 从实体集中删除冗余属性
当实体集之间需要一对多或多对多时，无法将其中一个实体集的主键作为单值主键键入另一个实体集，
此时便需要创建一个独立的关系集，重复属性作为主键的实体集中保留，另一个作为冗余删除。

## 7.5 实体-联系图

### 7.5.1 基本结构
* 分成两部分的矩形：实体集。第一部分代表实体集的名字，第二部分包含实体集中所有属性的名字
* 菱形：联系集
* 未分割的矩形：联系集的属性
* 线段：将实体集连接到联系集
* 虚线：将联系集属性连接到联系集
* 双线：实体在联系集中的参与度
* 双菱形：连接到弱实体集的标识性联系集
### 7.5.2 映射基数
箭头表示单，线段表示多。

### 7.5.3 复杂的属性
用缩进表示

### 7.5.4 角色
菱形和矩形之间连线上进行标注来表示角色。

### 7.5.5 非二元的联系集
在一个联系集外至多允许一个箭头

### 7.5.6 弱实体集
* 没有足够的属性以形成主码的实体集称作**弱实体集**。
* 弱实体集必须与另一个称作**标识**或**属主实体集**的实体集关联才能有意义
* 弱实体集**存在依赖**于标识实体集，标识实体集拥有它所标识的弱实体集
* 标识实体集**拥有**它所标识的弱实体集
* 将弱实体集与其标识实体集相关联的联系称为**标识性联系**
* 标识性联系是从弱实体集到标识实体集的多对一，弱实体集在练习中的参与是全部的。标志性联系集不应该有任何描述性属性。
* 弱实体集中的**分辨符**是使得我们区分其中实体的方法，也成为该实体集的部分码。
* 弱实体集的主码由标识实体集的主码加上该弱实体集的分辨符构成。

弱实体集的分辨符以虚下划线标明

弱实体集可以作为属主与另一个弱实体集参与一个一个标识性联系。

## 7.6 转换为关系模式
实体集、联系集都有唯一的关系模式与之对应，关系模式名即为相应的实体集或联系集的名称。

### 7.6.1 具有简单属性的强实体集的表示
强实体集主码 => 关系模式主码
强实体集属性 => 关系模式属性

### 7.6.2 具有复杂属性的强实体集的表示
1. 将复合属性拆分为多个简单属性，复合属性本身不再需要。
2. 为多值属性创建新的关系模式，新增的关系模式上建立外码约束
    * 在一个实体集只有两个属性的情况下--一个主码 B 以及一个多值属性 M---该实体集的关系模式只包含一个属性，即主码属性 B。可以删掉这个关系，同时保留具有属性 B 和对应 M 的属性 A 的关系模式。
3. 派生属性在关系模型中不显式表示出来

### 7.6.3 弱实体集的表示
* 关系模式主码 = 其所依赖的强实体集的主码+弱实体的分辨符。
* 外码约束：其所依赖的强实体集的主码产生的属性参照强实体集的主码。
* 完整性约束“级联删除”，弱实体依赖的强实体元组被删除，则一并删除。

### 7.6.4 联系集的表示
关系模式属性=所有参与的实体集的主码并集+描述属性

* 二元联系 多对多 参与实体集主码属性的并集
* 二元联系 一对一 任意一个实体集的主码
* 二元联系 多对一/一对多 “多”的一方的主码
* n 元联系 无箭头 所有参与实体集主码属性的并集
* n 元联系 1个箭头 除“箭头”侧的实体集的主码属性的并集。

#### 7.6.4.1 模式的冗余
连接弱实体集和相应强实体集的联系集比较特殊：
* 多对一
* 没有描述性属性
* 弱实体集主码包括强实体集的主码
于是它们产生的模式是冗余的，在关系模型中省略

#### 7.6.4.2 模式的合并
* 适用于存在“一”的情况下合并关系集。即“一对一”、“一对多”、“多对一”。
* 合并之后把关系集的属性加入“多”的那个实体集，主码是该实体集的主码。
* 一对一的时候可以在两个实体集中任选一个进行合并
* 即使参与是部分的，也可以使用空值进行合并
* 合入的那个外码依赖舍弃，另一个外码约束加入到合并的模式中。

## 7.7 实体-联系设计问题

### 7.7.1 用实体集还是属性
实体集更具备通用性，属性更为原子

何时使用实体集？通常为一个多值属性创建一个新的实体集
* 该组成部分的对应数量是否大于一
* 该组成部分是否有额外信息

错误：（虽然在关系设计模型的表中是事实结果）
1. 用一个实体集的主码作为另一个实体集的属性，而不是用关系。
2. 将实体集的主码属性作为联系集的属性（事实上已经在联系集中隐含）

### 7.7.2 用实体集还是联系集
取决于这个联系产生的事实结果是否需要用于其他地方。
原则是：当描述发生在实体间的行为时采用联系集。

### 7.7.3 二元还是 n 元联系集
一个非二元的联系集总可以用一组不同的二元联系集来代替。

### 7.7.4 联系属性的布局
将描述性属性作为联系集的属性还是实体集的属性反映出被建模企业的特点。

多对多只能放在联系集的属性中

## 7.8 扩展的 E-R 特性
用更恰当的方式来表述特定模型

### 7.8.1 特化
在实体集内部进行分组的过程称为特化
* 允许多个集称为重叠特化，分开使用多个箭头
* 允许至多一个集称为不相交特化，使用一个公用箭头

### 7.8.2 概化
概化是高层实体集与一个或多个低层实体集间的包含关系。
高层（更具共性）与低层（更具体）实体集也可以分别称作超类（父类）和子类。

E-R 图中概化和特化表示不作区分。

### 7.8.3 属性继承 参与继承
* 高层实体集所关联的所有属性和联系适用于他的所有低层实体集
* 低层实体集特有的性质仅适用于特定的低层实体集

分为单继承和多继承，多继承产生的结构被称为格。

### 7.8.4 概化上的约束
一、判断哪些实体属于哪些低层实体集
1. 条件定义的，也叫属性定义的，根据特定条件自动判断
2. 用户定义的，用户自行指定其低层实体集归属
二、在一个概化中一个实体是否可以属于多个低层实体集
1. 不相交：一个实体至多属于一个低层实体集
2. 重叠：同一个实体可以同时属于同一个概化中的多个低层实体集。
三、概化的完全性约束
1. 全部概化/特化：每个高层实体必须属于一个低层实体集。
2. 部分概化/特化：允许一些高层实体不属于任何底层实体集。（默认）

### 7.8.5 聚集
为了表达联系间的联系
聚集是一种抽象，联系被视为高层实体与其他联系相联系。

### 7.8.6 转换为关系模式
#### 7.8.6.1 概化的表示
两种方式
* 为高层实体集创建一个模式，为每个低层实体集创建一个模式。在低层实体集上建立外码约束
* 特殊的，如果概化不相交且是完全的，可只为低层实体集创建一个模式，但此时无法实现外码约束。

#### 7.8.6.2 聚集的表示
同两个实体间的联系集一样看待

## 7.9 数据建模的其他表示法

# 第三章 SQL

## 3.2 SQL数据定义

### 3.2.2 基本模式定义
完整性约束
* primary key
* foreign key
* not null

## 3.3 SQL查询的基本结构
SQL查询的基本结构由三个子句构成：select、from 和 where。

### 3.3.1 单关系查询

    -- 强行删除重复，加入关键词 distinct
    select distinct dept_name 
    from instructer;

    -- 显示指明不去除重复，加入关键词 all（默认）
    select all dept_name 
    from instructer;

    -- select 子句可以使用+、-、*、/运算符
    select ID,name,dept_name,salary*1.1
    from instructer;

    -- where 子句可以只选出在from子句结果关系中满足特定谓词的元组
    -- 可以在其中使用 **and、or、not**
    -- 运算对象可以是包含比较运算符<、<=、>、>=、=、<>的表达式
    select ID,name,dept_name,salary*1.1
    from instructer; 

### 3.3.2 多关系查询

* select 子句用于列出查询结果中所需要的属性。
* from 子句是一个查询求值中需要访问的关系列表
* where 子句是一个作用在 from 子句中关系的属性上的谓词

一个 SQL 查询的含义可以理解如下
1. 为 from 子句中列出的关系产生笛卡尔积。
2. 在步骤1的结果上应用 where 子句中指定的谓词
3. 对于步骤2结果中的每个元组，输出 select 子句中指定的属性（或表达式的结果）。

### 3.3.3 自然连接

公共属性，第一个关系中独有属性，第二个关系中独有属性


    select name,title
    from instructor natural join teaches,course
    where teaches.course_id=course.course_id;
    
    -- 与上一条结果并不同，此条 SQL 要求其中的所有同名属性都相等
    select name,title
    from instructor natural join teaches natural join course;

    -- 连接构造：r1 join r2 using (A1,A2)，此时仅需要A1，A2匹配，即使存在同名属性A3不相等也可以连接
    select name,title
    from (instructor natural join teaches) join course using (course_id);

## 3.4 附加的基本运算

### 3.4.1 更名运算
目的：改变结果集中的属性的名字、参与计算的关系的名字

`old-name as new-name` 可用于 select 及 from 子句，新旧名字是同一个东西。

* 重命名关系简化其他地方的引用
* 比较同一个关系时，即关系自身的笛卡尔积区分

重命名关系标识符被称为相关名称、表别名、相关变量、元组变量

### 3.4.2 字符串运算
* SQL 使用单引号标识字符串，双单引号表示字符串中的单引号
* 字符串大小写敏感，可以设置
* 字符串上可以使用函数
* like 操作符模式匹配，模式大小写敏感,
    * 百分号（%）：匹配任意子串。
    * 下划线（_）：匹配任意一个字符。
    * 用法：`where building like '%Waston%'`;
    * 转移字符：使用escape关键字定义转义字符，like `'ab\\cd%' escape '\'`
* not like 表示不匹配。
* 另外，`similar to` 类似 UNIX 中的正则。

### 3.4.3 select 子句中的属性说明
（*）表示所有的属性，即通配符

### 3.4.4 排列元组的显示次序
* order by 子句默认使用升序，
* desc 表示降序，
* asc 表示升序，
* 排序可在多个属性上进行，依次应用以排序

### 3.4.5 where 子句谓词
between and 表示区间，包含边界，另有not between

(v1,v2,...,vn)可以表示分量值为 v1,v2,...,vn 的 n 维元组，类似数组比较，按字典顺序比较

## 3.5 集合运算
对查询结果进行的运算

### 3.5.1 并运算
union 运算自动去重
union all 保留重复，两者原样保留

### 3.5.2 交运算
intersect 运算自动去重
intersect all 保留重复，数量为较少的那个表的元组数量

### 3.5.3 差运算
except运算之前去除重复
except 前者减去后者中匹配数量

## 3.6 空值
如果 where 子句谓词对一个元组计算出 false 或 unknown,那么该元组不能被加入到结果集中。

is null、is not null 来判断空或非空。

某些 sql 实现中还支持 is unkown、is not unknown

select distinct中，值非空且相等，或者都是空,那么就是相等的，保留一份拷贝。

## 3.7 聚集函数

### 3.7.1 基本聚集
    select avg(salary) as avg_salary
    ...

    -- 使用 distinct 来去重
    select count(distinct ID)

    -- 找出元组数，这里不能使用distinct
    select count (*)

### 3.7.2 分组聚集
保证出现在 select 子句中但没有被聚集的属性只能是出现在 group by 子句中的那些属性。

### 3.7.3 having 子句
作用对象是分组条件的限定，用来对分组之后的结果进行限定
having 子句中的谓词在形成分组后才起作用，因此可以使用聚集函数。

任何出现在 having 子句中，但没有被聚集的属性必须出现在 group by 子句中。

    select dept_name,avg(salary) as avg_salary
    from instructor
    group by dept_name
    having avg(salary) > 42000;

1. 与不带聚集的查询情况类似，最先根据 from 子句来计算出一个关系
2. 如果出现了 where 子句，where 子句中的谓词将应用到 from 子句的结果关系上。
3. 如果出现了 group by 子句，满足 where 谓词的元组通过 group by 子句形成分组，如果没有出现 group by 子句，满足 where 谓词的整个元组集被当作一个分组。
4. 如果出现了 having 子句，它将应用到每个分组上；不满足 having 子句谓词的分组将被抛弃。
5. select 子句利用剩下的分组产生出查询结果中的元组，即在每个分组上应用聚集函数来得到单个结果元组。

### 3.7.4 对空值和布尔值的聚集
除了 count(*) 外所有的聚集函数忽略输入中的空值

若输入全为空值。count运算符结果为0，其他运算返回一个空值

布尔值聚集函数：some、every

## 3.8 嵌套子查询
用在 where 子句中，作为筛选元组的条件

### 3.8.1 集合成员资格
连接词 in 测试元组是否是集合中的成员

### 3.8.2 集合的比较
短语“至少比某一个大”在 SQL 中用 >some 
=some 等价于 in。但 <>some 不等价于 not 

短语“比所有的都大”在 SQL 中用 >all 表示。
<>all 等价于 not in，但=all不等价于 

### 3.8.3 空关系测试
SQL 还有一个特性可测试一个子查询的结果中是否存在元组。

来自外层查询的一个相关名称可以用在 where 子句的子查询中。使用了来自外层查询相关名称的子查询被称作相关子查询。

### 3.8.4 重复元组存在性测试
union结构 union（子句）

### 3.8.5 from 子句中的子查询
select-from-where 表达式的结果也是关系，因此可以出现在任何关系可以出现的地方

### 3.8.6 with 子句
with 子句预先定义即将使用的临时关系，建华子查询

### 3.8.7 标量子查询
子查询可以出现在任何返回单个值的表达式能够出现的地方，只要改子查询只返回包含单个属性的单个元组。

可以出现在select、where 和 having 子句中，

## 3.9 数据库的修改
### 3.9.1 删除
### 3.9.3 更新
SQL 提供 case 结构

    update instructor
    set salary = case
                 when pred1 then result1
                 when pred2 then result2
                 ...
                 when predn then resultn
                 else result0
                 end


# 4 中级 SQL

## 4.1 连接表达式

### 4.1.1 连接条件
使用场景：根据某些条件将不同的关系相连接，on 表达了满足什么情况才将元组相连接。是对关系连接时的限定
on 条件允许在参与连接的关系上设置通用的谓词。
jion..on..

### 4.1.2 外连接
内连接：未匹配任何元组的元组将不被保留

where子句会排除内连接舍弃掉的元组，而on则会保留

## 4.4 完整性约束

### 4.4.1 单个关系上的约束
* not null
* unique
* check(<谓词>)
### 4.4.2 not null 约束
not null 声明禁止在该属性上插入空值

### 4.4.3 unique 约束
指明多个属性形成一个候选码

### 4.4.4 check 子句
指定给元组的约束

### 4.4.5 参照完整性

## 4.5 SQL 的数据类型和模式

### 4.5.1 SQL中的 日期和时间类型
记录日期时间时区
转换类型
提取单独信息

### 4.5.2 默认值

### 4.5.3 创建索引
加速查询

### 4.5.3 创建索引
### 4.5.5 用户定义类型
### 4.5.6 create table 的扩展

# 第八章 关系数据库的设计

## 8.1 好的关系设计的特点

### 8.1.1 设计选择：更大的模式
### 8.1.2 设计选择：更小的模式

## 8.2 原子域和第一范式
消除子结构
* 组合属性：让每个子属性本身成为一个属性
* 多值属性：为多值集合中的每个项创建一条元组。

在关系模型中，我们将属性不具有任何子结构这个思想形式化。一个域是原子的，如果该域的元素被认为是不可分的单元。我们成一个关系模式R属于第一范式，如果R的所有属性的域都是原子的。

## 8.3 使用函数依赖进行分解

* 希腊字母（例如 α ）：属性集
* 小写罗马字母跟一个圆括号内的大写字母（例如 r(R)）：关系模式
    * 关系 r
    * 属性集 R
    * 不关心关系的名字时使用 R 代表 r(R)
    * 小写希腊字母可能是模式也可能不是模式的属性集
* 属性集是一个超码时，用 K 表示
* 关系使用小写的名字，示例中使用单个字母

### 8.3.1 码和函数依赖
超码是能够唯一标识整条元组的属性集

函数依赖让我们可以表达唯一标识某些属性的值的约束。
单输入对应单输出。

* 判定关系的实例是否满足给定函数依赖集F。
* 说明合法关系集上的约束。

平凡的函数依赖：在所有关系中都满足

即使在关系实例中满足某些函数依赖，但他们可能并不是必要的。

F+表示 F 集合的闭包，也就是能够从给定 F 集合推到出的所有函数依赖的集合。显然，F+包含 F 中所有的函数依赖。

### 8.3.2 Boyce-Codd 范式 BCNF
消除所有基于函数依赖能够发现的冗余

### 8.3.3 BCNF 和保持依赖
第二范式已经被淘汰了

### 8.3.4 第三范式

## 8.4 函数依赖理论

### 8.4.1 函数依赖集的闭包

### 8.4.2 属性集的闭包


## 9.4 应用架构
拆分多层以减少复杂性
